from enum import Enum
from glob import glob
import importlib

import telegram

import octobot.exceptions
import octobot.handlers
import logging

from octobot.utils import path_to_module
from settings import Settings

logger = logging.getLogger("Loader")


class PluginStates(Enum):
    loaded = 0
    unknown = 1
    error = 2
    notfound = 3


class OctoBot(telegram.Bot):
    """
    Module loader class. Inherited from telegram.Bot

    :param load_list: List of plugins to load in module syntax
    :type list:
    :param \*args: Arguments to pass to telegram.Bot class
    :param \*\*kwargs: Keyword arguments to pass to telegram.Bot class
    """
    plugins = {}
    handlers = {}

    def __init__(self, load_list, *args, **kwargs):
        super(OctoBot, self).__init__(*args, **kwargs)
        self.me = self.getMe()
        for plugin in glob("base_plugins/*.py"):
            logger.info("Loading base plugin %s", plugin)
            self.load_plugin(path_to_module(plugin))
        if len(load_list) > 0:
            load_list_actual = []
            for plugin in load_list:
                load_list_actual.append(path_to_module(plugin))
            self.load_plugins({"exclude": [], "load_order": load_list_actual})
        else:
            plugins = self.discover_plugins()
            self.load_plugins(plugins)

    @staticmethod
    def discover_plugins():
        """
        Search for plugins

        :return: Load dictionary for load_plugins. Consists of "exclude" and "load_order" keys
        :rtype: dict
        """
        modlist = []
        for plugin in glob('plugins/*.py'):
            plugin = path_to_module(plugin)
            modlist.append(plugin)
        load_list = dict(exclude=Settings.exclude_plugins, load_order=modlist)

        return load_list

    def update_handlers(self):
        """
        Updates handlers from self.plugins. Usually gets called after :meth:`load_plugins` or :meth:`load_plugin` (if `single_load=True`)
        """
        self.handlers = {}
        for plugin in self.plugins.values():
            module = plugin["module"]
            for var_name in dir(module):
                var = getattr(module, var_name)
                if isinstance(var, octobot.handlers.BaseHandler):
                    var.plugin = plugin
                    if var.priority not in self.handlers:
                        self.handlers[var.priority] = []
                    self.handlers[var.priority].append(var)
        logger.info("Handlers update complete, priority levels: %s", self.handlers.keys())

    def load_plugin(self, plugin: str, single_load=False):
        """
        Loads plugin

        :param plugin: Plugin name in module format (ex. `plugins.test`)
        :type plugin: str
        :param single_load: If plugin is loaded not together with other plugins (e.g. manually loaded from other plugin). Defaults to False
        :type single_load: bool,optional
        """
        self.plugins[plugin] = dict(name=plugin, state=PluginStates.unknown, module=None, friendly_name=plugin)
        try:
            plugin_module = importlib.import_module(plugin)
        except ModuleNotFoundError:
            self.plugins[plugin]["state"] = PluginStates.notfound
            logger.error("Plugin %s is defined in load_order, but cannot be found. Please check your load_list.json", plugin)
        except Exception as e:
            logger.error("Failed to load plugin %s", exc_info=True)
            self.plugins[plugin]["state"] = PluginStates.error
        else:
            self.plugins[plugin]["state"] = PluginStates.loaded
            self.plugins[plugin]["module"] = plugin_module
            logger.info("Loaded plugin %s", plugin)
        if single_load:
            self.update_handlers()
        return

    def load_plugins(self, load_list: dict):
        """
        Loads plugins using dict generated by :meth:`discover_plugins()`

        :param load_list: Load list. Usually generated by :meth:`discover_plugins()`
        """
        for plugin in load_list["load_order"]:
            if not plugin in load_list["exclude"]:
                self.load_plugin(plugin)
        self.update_handlers()
        return

    def handle_update(self, bot, update):
        logger.debug("handling update %s", update.to_dict())
        try:
            ctx = octobot.Context(update)
        except octobot.exceptions.UnknownUpdate:
            logger.warning("Failed to determine update type: %s", update.to_dict())
            return
        for handlers in self.handlers.values():
            try:
                for handler in handlers:
                    try:
                        ctx._plugin = handler.plugin
                        handler.handle_update(bot, ctx)
                    except octobot.exceptions.StopHandling as e:
                        raise e
                    except Exception as e:
                        logger.error("Handler threw an exception!", exc_info=True)
            except octobot.exceptions.StopHandling:
                break
